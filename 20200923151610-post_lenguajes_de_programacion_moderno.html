<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>
  20200923151610-post_lenguajes_de_programacion_moderno.html</title>
  <meta http-equiv="Content-Type" content=
  "application/xhtml+xml; charset=us-ascii" />
  <link rel="stylesheet" type="text/css" media="all" href=
  "https://cdn.jsdelivr.net/npm/github-markdown-css/github-markdown.min.css" />
  <link rel="stylesheet" type="text/css" media="all" href=
  "https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/github.min.css" />
  <meta name='viewport' content=
  'width=device-width, initial-scale=1, shrink-to-fit=no' />
  <style type="text/css">
/*<![CDATA[*/
  body { box-sizing: border-box; max-width: 740px; width: 100%; margin: 40px auto; padding: 0 10px; } 
  /*]]>*/
  </style>
  <script src=
  'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/highlight.min.js'
  type="text/javascript">
</script>
  <script type="text/javascript">
//<![CDATA[
  document.addEventListener('DOMContentLoaded', () => { document.body.classList.add('markdown-body'); document.querySelectorAll('pre[lang] > code').forEach((code) => { code.classList.add(code.parentElement.lang); }); document.querySelectorAll('pre > code').forEach((code) => { hljs.highlightBlock(code); }); });
  //]]>
  </script>
</head>

<body>
  <p>#+TITLE: Post: Lenguajes de Programaci&Atilde;&sup3;n Moderno
  #+CREATED: [2020-09-23 Wed 15:16] #+LAST_MODIFIED: [2020-09-23
  Wed 15:16] #+public: true</p>

  <ul>
    <li>tags:: [[file:20200922032244-clojure.org][Clojure]]
    [[file:20200920112829-elm.org][Elm]]
    [[file:20200920163655-elixir.org][Elixir]]
    [[file:20200920112816-rust.org][Rust]]
    [[file:20200923151657-posts.org][Posts]] :PROPERTIES: :ID:
    a660e678-3519-4f70-bc8d-ce8646d0ee03 :END:</li>
  </ul>

  <ul>
    <li>Outline [2/4]</li>

    <li>
      <ul>
        <li><input checked="checked" disabled="disabled" type=
        "checkbox" />Intro Existen muchos lenguajes de
        programaci&Atilde;&sup3;n, quiz&Atilde;&iexcl; demasiados,
        cada uno enfocado a solucionar alg&Atilde;&ordm;n problema
        en particular o con alguna orientaci&Atilde;&sup3;n
        diferente. Algunos de estos han sucumbido a los cambios y
        otros se han mantenido estoicos durante los
        a&Atilde;&plusmn;os y unos pocos han superado todo cambio y
        son parte escencial de la tecnolog&Atilde;&shy;a que usamos
        hoy en d&Atilde;&shy;a. Entre estos a&Atilde;&plusmn;osos
        monstruos tenemos C, nacido en 1972, C++ en 1985, Java,
        Javascript, Python, Php, Ruby, todos ellos nacidos en los
        90. Si bien estos leguajes a&Atilde;&ordm;n siguen en boga
        y tienen un gran mercado, es f&Atilde;&iexcl;cil ver que se
        han vuelto muy complejos a la hora de enfrentar los
        problemas de hoy en d&Atilde;&shy;a</li>
      </ul>
    </li>

    <li>
      <ul>
        <li><input checked="checked" disabled="disabled" type=
        "checkbox" />Content El t&Atilde;&copy;rmino
        <strong>moderno</strong> es una clasificaci&Atilde;&sup3;n
        a lo menos controversial, es complejo definir que es
        moderno ya que cada uno puede tener prejucios y
        preconceptos sobre que considerar actual o no, pero en el
        scope de este post consideraremos modernos a lenguajes
        nacidos durante la <strong>&Atilde;&ordm;ltima
        decada</strong> y que contemplan algunas
        caracter&Atilde;&shy;sticas que en general la comunidad de
        desarrolladores a llegado a desear y definir como
        b&Atilde;&iexcl;sicos.</li>
      </ul>
    </li>
  </ul>

  <p>*** La necesidad de la invenci&Atilde;&sup3;n La
  tecnolog&Atilde;&shy;a de hoy es, claramente, diferente a la de
  hace 40-50 a&Atilde;&plusmn;o, hoy los sistemas y aplicaciones
  deben soportar computadores <strong>multi-core</strong>, uso de
  <strong>gpu</strong>, dispositivos m&Atilde;&sup3;vules,
  <strong>cloud computing</strong>, etc. En general, un concepto
  que engloba estos t&Atilde;&copy;rminos es
  <strong>Concurrencia</strong>. La mayor&Atilde;&shy;a de los
  lenguajes <em>antiguos</em> se han actualizado con los
  a&Atilde;&plusmn;os para dar soporte a estos nuevos
  requerimientos, por ejemplo Java agreg&Atilde;&sup3; expresions
  Lambda y Streams en su versi&Atilde;&sup3;n 8. El problema es que
  estos lenguajes no fueron dise&Atilde;&plusmn;ados con estos
  requerimientos en mente. Es por esto que cada a&Atilde;&plusmn;o
  vemos el nacimiento de alg&Atilde;&ordm;n nuevo lenguaje que
  incluye alguna caracter&Atilde;&shy;stica especial que le da
  vida, dentro de este grupo hay algunos lenguajes que destacan por
  los diferentes approaches que proponen para enfrentar los
  problemas de la tecnolog&Atilde;&shy;a actual.</p>

  <p>Algunas de estas caracter&Atilde;&shy;sticas son:</p>

  <ul>
    <li>Soporte nativo para concurrencia</li>

    <li>Inmutabilidad</li>

    <li>Inferencia de tipos y type safety</li>

    <li>Programaci&Atilde;&sup3;n funcional,</li>

    <li>Tipos est&Atilde;&iexcl;ticos</li>

    <li>Nuevos tipos de sintaxis</li>

    <li>Developer Experience</li>
  </ul>

  <p>Algunos de estos lenguajes, que en base a estas
  caracter&Atilde;&shy;sitcas, se muestran como
  <strong>modernos</strong> son:</p>

  <ul>
    <li>
      <p>Rust</p>
    </li>

    <li>
      <p>Elm</p>
    </li>

    <li>
      <p>Clojure</p>
    </li>

    <li>
      <p>Elixir</p>
    </li>

    <li>
      <p>Kotlin</p>
    </li>

    <li>
      <p>Swift</p>
    </li>

    <li>
      <p>Scala</p>
    </li>

    <li>
      <p>Grain</p>
    </li>

    <li>
      <p>Unison</p>
    </li>

    <li>
      <p>Dark</p>

      <p>Lo que sigue es un overview de algunos de estos lenguajes,
      describiendo algunos de los features que cada uno de ellos
      presenta, me enconfar&Atilde;&copy; en Rust, Elm y Clojure.
      Intencionalmente me he dejado fuera Kotlin y Swift. Kotlin y
      Swift son claramente lenguajes modernos,nacieron para cubrar
      una necesidad moderna, desarrollar aplicaciones
      m&Atilde;&sup3;viles, los dejo fuera de este listado por
      que:</p>

      <ul>
        <li>Tienen un futuro claro</li>

        <li>Son lenguajes de nicho (cada uno para su
        plataforma)</li>
      </ul>
    </li>
  </ul>

  <p>** TODO Overview Comenzaremos esta lista con
  <strong>Rust</strong> un lenguaje que considero tiene un gran
  potencial y que ha crecido enormemente tanto en su set de
  caracter&Atilde;&shy;sticas como en el tamaa&Atilde;&plusmn;o de
  su comunidad.</p>

  <p>*** Rust Se autodefine como un lenguaje para <strong>empoderar
  a todos a construir software confiable y eficiente</strong>, nace
  como una alternativa a C++. Es un lenguaje de uso general, se
  puede usar para casi todo, incluyendo aplicaciones web al
  compilar como wasm.</p>

  <p>Uno de sus objetivos es ser eficitiente y tener una gran
  performance en runtime. Otras de sus caracter&Atilde;&shy;sticas
  son:</p>

  <p><strong>** Compila como binario, no tiene garbage collector es
  como C++ **</strong> Tiene interoperaci&Atilde;&sup3;n con C/C++
  <strong>** Tiene un manejador de paquetes, plugins para editores,
  material de aprendizaje (ej: <a href=
  "https://github.com/rust-lang/rustlings">https://github.com/rust-lang/rustlings</a>
  y <a href=
  "https://egghead.io/playlists/learning-rust-by-solving-the-rustlings-exercises-a722?af=4cexzz">
  esta colecci&Atilde;&sup3;n en egghead</a> por <a href=
  "https://www.christopherbiscardi.com/the-rust-programming-language">
  Chris Biscardi</a>) **</strong> Es Backward compatible</p>
  <hr />

  <p>Al mismo tiempo, Rust se define como un lenguaje confiable, y
  esta confiablidad viene dada por caracter&Atilde;&shy;sticas como
  las siguientes <strong>** Revisi&Atilde;&sup3;n de tipos
  esst&Atilde;&iexcl;ticos **</strong> Un sistema de datos seguro
  (si el compilador te dice que es cierto tipo, entonces lo es )
  <strong>** Tiene datos reales, nada de <code>any</code> (alo!
  Typescript) **</strong> No incluye el <a href=
  "https://www.youtube.com/watch?v=ybrQvs4x0Ps">"error del billon
  de dolares"</a>, es decir, no existen referencias
  <code>null</code> ni <code>undefined</code> ni similares.
  <strong>** Tiene un compilador que de verdad entrega ayuda cuando
  existen errores **</strong> Es un lenguaje con datos inmutables
  por defecto, pero ofrece formas de modicar este comportamiento
  <strong>** Tiene seguros de acceso a memorio **no data
  races</strong> **** Si compila, usualmente significa que
  funciona</p>
  <hr />

  <p>Rust es un lenguaje complejo, con muchos conceptos que
  aprende, pero tiene una comunidad bastante activa lo que ayuda
  mucho a la hora de aprender, actualmente podemos encontrar 6
  grandes conferencias, adem&Atilde;&iexcl;s su desarrollo es
  constante contanto con varios developers full-time y una gran
  cantidad de colaboradores.</p>

  <p>Un ejemplo de c&Atilde;&sup3;digo en Rust, para pattern
  matching. #+BEGIN_SRC rust enum Coin { Penny, Nickel, Dime,
  Quarter, }</p>

  <p>fn value_in_cents(coin: Coin) -&gt; u8 { match coin {
  Coin::Penny =&gt; 1, Coin::Nickel =&gt; 5, Coin::Dime =&gt; 10,
  Coin::Quarter =&gt; 25, } } #+END_SRC <strong>*
  [[file:20200920112829-elm.org][Elm]]</strong> ** Un lenguaje
  disfrutante para crear aplicaciones web confiables ** Puede ser
  considerado una alternativa a Javascript <strong>** Se utiliza
  para construir aplicaciones web **</strong> Disfrutable: Elm se
  enfoca en DX y ergon&Atilde;&sup3;micos: Gran compilador y
  mensajes de error <strong>** Enfocado en un compilador
  r&Atilde;&iexcl;pdio, friendly **</strong> Es
  peque&Atilde;&plusmn;o y simple <strong>** JS interop **</strong>
  packages, editor plugin, mateiral de aprendizaje *<strong>*
  Comparado con JS frameworks lo que no es correcto, Elm es un
  lenguaje, con los frameworks escribes JS/TS *</strong> Pero Elm
  tiene todo incluido, no se requiere un framework, Elm es el
  framework en si mismo. <strong>** Nacido el 2012 single dev.
  ahora tiene un Core Team y un BDFL</strong> ***
  &acirc;&euro;&oelig;What is Success?&acirc;&euro;
  youtu.be/uGlzRt-FYto (Evan Czaplinsky - creador) * 1 full time
  dev <strong><strong>* small, simple, release del compilador
  poco</strong> ** Elm tiene 5 conferencias. Healthy community
  (Menor que JS) **</strong> Reliable/Confiabilidad * Static
  type-checking <strong><strong>* sound type system (si el
  compilador dice que es el tipo, entonces lo es)</strong>
  **</strong> obviamente si se usa interop con C podria no ser
  cierto * No <code>any</code> (strict mode) <strong><strong>* No
  "billion dolar mistak" (null) *</strong></strong> Helpful
  compilers <strong>**</strong> Incluye mensajes de error que
  incluso te dicen como reparar el error <strong><strong>* If it
  compiles, it usually works. *</strong></strong> Immutable by
  default: 100% immutable, pure function language <strong><strong>*
  Elm compiled bundle size is one of the smaller
  *</strong></strong> No runtime exceptions: <strong>**</strong> El
  compilador lo evita gracias al sistema de tipado
  <strong>**</strong> Es posible pero demasiado dificil o
  extra&Atilde;&plusmn;o que ocurra, a menos que exista interop con
  JS *** [[file:20200920163655-elixir.org][Elixir]] <strong>**
  Nacido el 2011 por Jos&Atilde;&copy; Valim, parte del equipo Core
  de RoR **</strong> Un lenguaje dyn&Atilde;&iexcl;mico y funcional
  para construir aplicaciones escalables yu mantenibles <strong>**
  Toma el poder de la VM Erlang conocida por ejecutar sistemas
  distribuidos de baja latencia **</strong> Se utiliza para
  desarrolo web, software embebido, procesamiento multimedia, ena
  <strong>** Enfocado en Escalabilidad, tolerancia a fallo y
  concurrencia **</strong> Completamente funcional <strong>** 100%
  Immutable **</strong> Incluye extensibilidad mendiante el uso de
  un DSL <strong>** REPL y manejador de paquetes **</strong>
  Compatible con Erlang **** Tiene una comunidad activa y una gran
  conferencia llama ElixirConf en total hay 13 grandes eventos a
  nivel mundial. **</p>

  <p><strong>* [[file:20200922032244-clojure.org][Clojure]]
  :PROPERTIES: :ID: 8c53485f-f2f7-472a-a2bd-3b7950b47caf
  :END:</strong> ** Nacido el 2007, actualmente mantenido por
  Cognitect con 126 contributors formales ** Un lenguaje robusto,
  practico y r&Atilde;&iexcl;pido con caracter&Atilde;&shy;siticas
  para forma una herramienta simple, coherente y poderosa.
  <strong>** De prop&Atilde;&sup3;sito general, **</strong>
  Interoperabilidad con Java *<strong>* Es un dialecto de Lisp y
  comparte la filosof&Atilde;&shy;a codigo-como-datos *</strong>
  Esto se conoce como homoiconocidad. El propio programa ecrito
  puede ser manipulado como data usando el propio lenguaje.
  <strong>** Funcional **</strong> Estructuras de datos inmutables
  <strong>** Polimorfismo **</strong> Soporta Macros *<strong>**
  Provee la oporatuniad de extender el lenguaje ****</strong>
  Confiable and Battle tested: Utilizado por Citibank, Simple,
  Amazon, Netflix, etc. <strong>** Se ejecuta en la JVM **</strong>
  Gran comunidad, un ejemplod ello es el project ClojureFam del que
  participo para aprender Clojure <strong>** Tiene dos conferencias
  anuales US para un total de entre 7 y 8 conferencias mundiales
  (incluyendo una remota) **</strong> Tambi&Atilde;&copy;n puede
  ser usado en el browser con Clojurecript, un compilador de
  Clojure que crea c&Atilde;&sup3;digo JS</p>

  <p>** TODO Summary</p>
</body>
</html>
